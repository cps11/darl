import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable

class Generator(nn.Module):
    """Generator """
    def __init__(self, num_emb, emb_dim, hidden_dim, device):
        super(Generator, self).__init__()
        self.num_emb = num_emb
        self.emb_dim = emb_dim
        self.hidden_dim = hidden_dim
        self.device = device
        self.emb = nn.Embedding(num_emb, emb_dim)
        self.lstm = nn.LSTM(emb_dim, hidden_dim, batch_first=True)
        self.lin = nn.Linear(hidden_dim, num_emb)
        self.softmax = nn.LogSoftmax()
        self.init_params()

    def forward(self, x):
        """
        Args:
            x: (batch_size, seq_len), sequence of tokens generated by generator
        """
        emb = self.emb(x)
        h0, c0 = self.init_hidden(x.size(0))
        output, (h, c) = self.lstm(emb, (h0, c0))
        output = self.lin(output)
        return output
        # pred = self.softmax(self.lin(output.contiguous().view(-1, self.hidden_dim)))
        # return pred

    def step(self, x, h, c):
        """
        Args:
            x: (batch_size,  1), sequence of tokens generated by generator
            h: (1, batch_size, hidden_dim), lstm hidden state
            c: (1, batch_size, hidden_dim), lstm cell state
        """
        emb = self.emb(x)
        output, (h, c) = self.lstm(emb, (h, c))
        output = self.lin(output)
        pred = F.softmax(output, dim=-1)
        return pred, h, c


    def init_hidden(self, batch_size):
        h = Variable(torch.zeros((1, batch_size, self.hidden_dim), device=self.device))
        c = Variable(torch.zeros((1, batch_size, self.hidden_dim), device=self.device))
       
        return h, c

    def init_params(self):
        for param in self.parameters():
            param.data.uniform_(-0.05, 0.05)

    def sample(self, batch_size, seq_len, x=0):
        if isinstance(x, int):
            x = torch.zeros((batch_size, 1), device=self.device, dtype=torch.long)

        h, c = self.init_hidden(batch_size)

        samples = torch.zeros([batch_size, seq_len], device=self.device, dtype=torch.long)        
        for i in range(x.shape[1]):
            output, h, c = self.step(x[:,i].view(batch_size, 1), h, c)
        x = torch.multinomial(output[:, -1, :], 1)
        samples[:, 0] = x[:, 0].to(torch.long)

        for i in range(seq_len-1):
            output, h, c = self.step(x, h, c)
            x = torch.multinomial(output[:, -1, :], 1)

            samples[:, i+1] = x[:, 0].to(torch.long)
        
        return samples